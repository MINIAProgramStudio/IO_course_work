\documentclass[a4paper,14pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[ukrainian]{babel}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{indentfirst}
\usepackage{caption}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{float}
\usepackage{tocloft}
\usepackage{enumitem}
\usepackage{pdfpages} % для вставки титульного аркуша, якщо він як PDF

\def\code#1{\texttt{#1}}

\graphicspath{ {./img/} }


\geometry{left=3cm, right=1.5cm, top=2cm, bottom=2cm}
\setlength{\parindent}{1.25cm}
\setlength{\parskip}{0.5em}

% Стилі заголовків
\titleformat{\section}{\Large\bfseries\centering}{РОЗДІЛ \thesection.}{1em}{\MakeUppercase}
\titleformat{\subsection}{\normalsize\bfseries}{\thesubsection.}{0.5em}{}

% Стиль для змісту
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}
\usepackage{titlesec}
\titleformat{\section}[block]{\center\normalfont\Large\bfseries}{\thesection}{1em}{}

\def\changemargin#1#2{\list{}{\rightmargin#2\leftmargin#1}\item[]}
\let\endchangemargin=\endlist 
\makeatletter
\def\@makechapterhead#1{%
  %\vspace*{50\p@}%
  {\parindent \z@ \raggedright \normalfont
    \ifnum \c@secnumdepth >\m@ne
      \if@mainmatter
        %\huge\bfseries \@chapapp\space \thechapter
        \center\Huge\bfseries \thechapter.\space%
        %\par\nobreak
        %\vskip 20\p@
      \fi
    \fi
    \interlinepenalty\@M
    \Huge \bfseries #1\par\nobreak
    \vskip 40\p@
  }}
\makeatother

\begin{document}

\begin{center}
    \normalsize
    НАЦІОНАЛЬНИЙ ТЕХНІЧНИЙ УНІВЕРСИТЕТ УКРАЇНИ \\
    «КИЇВСЬКИЙ ПОЛІТЕХНІЧНИЙ ІНСТИТУТ імені Ігоря СІКОРСЬКОГО» \\
    Навчально-науковий Фізико-технічний інститут
\end{center}

\vspace*{4cm} % Вертикальний відступ від верхнього блоку до назви роботи

% Центральний блок (Назва роботи)
\begin{center}
    \Large \textbf{РОЗРАХУНКОВО-ГРАФІЧНА РОБОТА} \\
    \normalsize з кредитного модуля «Інтелектуальні обчислення» \\
    на тему: \\
    \textbf{"РОЗПІЗНАВАННЯ РОБОЧОЇ ПОВЕРХНІ СТОЛУ 3D ПРИНТЕРА ПРЯМИМИ ТА ІТЕРАЦІЙНИМИ МЕТОДАМИ, НЕЙРОННИМИ МЕРЕЖАМИ"} \\
\end{center}

\vspace*{4cm} % Вертикальний відступ від назви роботи до блоку "Виконав"

% Блок "Виконав" (праворуч)
\begin{changemargin}{10cm}{0cm} % Вирівнювання по правому краю
    Виконав: \\
    студент 3 курсу НН ФТІ \\
    Голуб Михайло Вікторович \\
    номер залікової книжки \rule{3cm}{0.4pt} % Лінія для номера залікової книжки
\end{changemargin}

\vspace*{3cm} % Відступ між блоками "Виконав" та "Перевірив"

% Блок "Перевірив" (праворуч)
\begin{changemargin}{10cm}{0cm} % Вирівнювання по правому краю
    Перевірив: \rule{4cm}{0.4pt} \\ \\ % Лінія для підпису
    Оцінка: \rule{4cm}{0.4pt} % Лінія для оцінки
\end{changemargin}

\vfill % Розтягує простір, щоб перемістити наступний вміст до низу сторінки

% Нижній колонтитул
\begin{center}
    Київ-- 2025
\end{center}

\tableofcontents
\newpage

% Розділ "Вступ"
\chapter{Вступ}
\section{Актуальність}
3D принтери технології пошарового наплавлення філаменту (Fused filament fabrication, далі -- FFF 3D принтери) зараз є найбільш поширеними верстатами для швидкого протипування.
Дана технологія має недолік високої кількості браку. Збільшення кількості завчасних зупинок друку через брак може бути досягнуто при використанні методів що використовують контекст (положення друкованого об'єкту в просторі відносно камери), аніж при використанні нейронних мереж які аналізують зображення без жодної додаткової інформації про 3D модель що друкується.
Для розробки і застосування покращених методів необхідно чітко знати положення столу, щоб визначити де на фотографії / відео має знаходитись 3D модель, яка друкується.
Першим кроком з створення таких методів є система розпізнавання робочої поверхні столу FFF 3D принтера.


\section{Мета роботи}
Мета роботи -- побудувати і порівняти методи розпізнавання робочої поверхні столу для FFF 3D принтера Bambulab A1 mini.
\begin{figure}[H]
  \center
  \includegraphics[height=10cm]{a1mini}
  \textbf{\caption{Bambulab A1 mini}}
  \label{fig:a1mini}
\end{figure}

\chapter{Допрограмний етап}
\section{Аналіз об'єкту, що розпізнається}
Необхідно розпізнати робочу поверхню столу FFF 3D принтера Bambulab A1 mini. Дана модель має декілька різних змінних робочих поверхонь, але найбільш розповсюджена -- PEI-пластина.\\
\begin{figure}[H]
  \center
  \includegraphics[width=0.7\textwidth]{PEIPlate}
  \textbf{\caption{PEI-пластина. На зображенні справа показано робочу зону}}
  \label{fig:PEI-plate}
\end{figure}

Робоча область PEI-пластини 18х18 см. Колір майже всіх PEI-пластин бронзово-золотистий. Отже, можна спробувати створити методи що шукають на зображенні проєкції квадратів, конкретний колір, або проєкції і колір одночасно.
Також, при використанні кольору як критерію пошуку, можна скористатись тим, що корпус даного 3D принтера в більшості місць білий.

Окрім роботи з значеннями пікселів для визначення кольору, можна скористатись тим, що робоча поверхня дуже контрастна з оточенням, корпусом принтера, і застосувати фільтр границь.

\section{Постановка задачі}
Програма має для вхідного зображення повернути 8 значень -- по дві координати чотирьох кутів столу/робочої області.

\section{Обрання методів розв'язку задачі}
Задачу розпізнавання об'єкту можуть виконати нейронні мережі, за наявності достатньої кількості розмічених зображень і функції втрат. 
Окрім нейронних мереж, можна застосувати ройові алгоритми, за умови наявності фітнес функції. 
Також, можна створити додатковий контекст, який гарантовано враховуватиме границі об'єктів та їх колір. Такий контекст можна подавати на вхід нейронних мереж чи ройових алгоритмів. 

\section{Створення методів отримання контексту}
\subsection{Отримання контексту з кольору пікселів}
З кольору пікселів можна створити контекст ввівши ідеальне значення кольору і допустимі відхилення. Доцільно це робити використавши HSV (трьохканальна система кольорів "Колірний тон, насиченість, яскравість"), а не RGB (трьохканальна система кольорів "Червоний, зелений, синій"), 
оскільки в HSV можна проігнорувати яскравість та враховувати лише колірний тон і насиченість.\\
Щоб отримати ідеальне значення кольорів столу і корпусу використано фотографію принтеру в типових умовах освітлення, отриману на камеру телефона.
\begin{figure}[H]
  \center
  \includegraphics[width=0.7\textwidth]{DSExample1.jpg}
  \textbf{\caption{Зображення принтера отримане за допомогою камери телефона}}
  \label{fig:DSExample1}
\end{figure}

Отримані значення RGB: (89, 65, 55) для столу і (219, 208, 202) для корпусу. Після переходу в HSV отримано (0.05, 0.382, 0.349) і (0.0583, 0.078, 0.859) відповідно. 
Покладено допустимі відхилення тону кольору і насиченості в 0.1 для столу. 
Покладено що насиченість для корпусу має бути менша за 0.2, при будь-якому значенні тону. Дані правила застосовані для даного зображення.
\begin{figure}[H]
  \center
  \includegraphics[width=0.7\textwidth]{HSVContext1.png}
  \textbf{\caption{Перший набір правил застосований до зображення: правила для столу червоним, правила для корпусу білим}}
  \label{fig:HSVContext1}
\end{figure}

Застосування даних правил значно зменшило область пошуку столу, проте вона все ще залишалася великою. З порівняння зображень видно, що правила для столу спрацьовують для світлих ділянок, а правила для корпусу -- для темних. 
Щоб уникнути таких спрацювань, було додано правило на яскравість: для столу яскравість має бути меншою за середню на зображенні, а для корпусу -- більшою.
\begin{figure}[H]
  \center
  \includegraphics[width=0.7\textwidth]{HSVContext2.png}
  \textbf{\caption{Другий набір правил застосований до зображення}}
  \label{fig:HSVContext2}
\end{figure}

Дане розширення правил ще раз значно зменшило область пошуку. Проте, частина столу не фарбується в червоний, відповідно необхідно збільшити допустимі відхилення тону і насиченості. Допустимі відхилення збільшено вдвічі.
\begin{figure}[H]
  \center
  \includegraphics[width=0.7\textwidth]{HSVContext3.png}
  \textbf{\caption{Третій набір правил застосований до зображення}}
  \label{fig:HSVContext3}
\end{figure}

\subsection{Отримання границь, як джерел контексту}
Для отримання контексту у вигляді границь об'єктів необхідно застосувати матричний фільтр границь:
\[
kernel = 
\begin{pmatrix}
-1 & -1 & -1\\
-1 & 8 & -1\\
-1 & -1 &-1
\end{pmatrix}\]
Даний фільтр застосовано до різних зображень: оригінального, оригінального в HSV та, чорно-білого. 
Після чого було взято середнє всіх трьох каналів. 
Для кращого відображення границь, розмір зображення зменшено в 8 разів.

\begin{figure}[H]
  \center
  \includegraphics[width=\textwidth]{BordersRaw.png}
  \textbf{\caption{Перший ряд: оригінальне зображення, застосування фільтру до RGB, застосування фільтру до середнього значення каналів RGB, застосування фільтру до HSV}}
  \label{fig:BordersRaw}
\end{figure}

З зображень видно, що фільтр HSV має занадто нечіткі лінії щоб використовуватись далі.

Для утворення чітких границь, необхідно їх перетворити у бінарні значення 0 і 1. Один з більш простих способів такого перетворення -- прогове перетворення:
\[1, pixel \geq threshold\]
\[0, pixel < threshold\]

\begin{figure}[H]
  \center
  \includegraphics[width=0.7\textwidth]{BordersMasked.png}
  \textbf{\caption{Порогова бінаризація RGB границь з порогом 0.2}}
  \label{fig:BordersMasked}
\end{figure}

\subsection{Використання попередніх результатів розпізнання}
Нехай програма вже успішно змогла розмізнати стіл в попередньому моменті часу (наприклад на попередньому кадрі відео), тоді відомо масив точок що входили в регіон столу. Оскільки хід столу вперед-назад не перевищує розміру самого столу, то якась частина попереднього масиву точок мають опинитись в новому регіоні столу.
Можна впровадити простий критерій, що хоча б одна точка з попереднього регіону столу, має бути в новому регіоні столу.

Якщо попередні моменти часу відсутні, можна попросити людину, або більш потужний розпізнавач розпізнати початкове положення столу. 
У разі використання людини користувача/оператора, їй достатньо вказати якусь точку столу, щоб звичайний розпізнавач за цією точкою знайшов стіл на першому зображенні. 

\section{Створення фітнес-функції для оцінки чотирикутників}
\subsection{Загальні вимоги до фітнес-функцій}
Фітнес-функція має приймати на вхід вершини чотирикутника, окрім вершин функція може приймати значення вершин в попередній момент часу, початкову точку та константи пов'язані з оброблюваним зображенням.

\subsection{Функція оцінки квадратності чотирикутника}
Квадрат є паралелограмом, з більшості кутів огляду (викривленням лінзи і перспективою для демонстраційних цілей роботи методів можна знехтувати). 
Паралелограми мають наступні властивості: їх протилежні сторони рівні, їх протилежні сторони паралельні.

Оцінка рівності протележних сторін:
\[
\theta_E = \frac{(E_1-E_3)^2}{E_1+E_3} + \frac{(E_2-E_4)^2}{E_2+E_4}\text{, де }E_i\text{ -- довжина ребра.}
\]
В оцінці рівності протилежних сторін присутнє ділення на суму цих протилежних сторін, інакше оцінка буде працювати по-різному для різних довжин ребер.


Оцінка паралельності протележних сторін:
\[
\theta_\alpha = (\alpha_1-\alpha_3)^2 + (\alpha_2 - \alpha_4)^2\text{, де }\alpha_i\text{ -- кут нахилу ребра в радіанах, }\frac{\pi}{2} \leq \alpha_i \leq \frac{3\pi}{2}.
\]

Об'єднання оцінок рівності і паралельності протилежних сторін можна виконати безліччю методів. Простішими з них є сума і множення. 
Сума оцінок зберігає незалежність оцінок і дозволяє покращувати одну оцінку, навіть якщо інша занулена. Але сума потребує балансування оцінок, інакше алгоритми і моделі будуть намагатись оптимізувати оцінку з найбільшим абсолютним значенням. 
Множення не має необхідності балансування оцінок, проте має проблеми, якщо якась з оцінок занулюється. Щоб уникнути занулення, до оцінок можна додати невелику константу.

Оцінки об'єднані наступним чином:
\[
\theta_{\text{пар.}} = (\theta_E + c_1) \cdot (\theta_\alpha + c_2)\text{, де }c_i\text{ -- константи уникнення занулення, які необхідно визначити експериментально.}
\]

\subsection{Функція оцінки наявності границь поруч з сторонами чотирикутника}
Оскільки по периметру столу 3D принтера майже завжди знаходяться границі, можна рахувати кількість пікселів границі поруч з сторонами чотирикутника. 
Нехай "поруч"\ це "сторона проходить через піксель". 
Для визначення пікселів через які проходить відрізок існує алгоритм Брезенхейма \cite{bresenham}. 
Загальне рівняння прямої через дві точки $(x_0, y_0)$, $(x_1, y_1)$:
\[
\frac{y-y_0}{y_1-y_0} = \frac{x-x_0}{x_1 - x_0}
\]
Алгоритм Брезенхейма, для всіх 8 напрямків прямої:
\begin{enumerate}
  \item p -- пустий масив точок;
  \item $\Delta x = |x_1 - x_0|$; $\Delta y = |y_1 - y_0|$;
  \item $sx = x_1 \geq x_0$; $sy = y_1 \geq y_0$;
  \item $x = x_0$; $y = y_0$;
  \item $D = argmax(\Delta x, \Delta y)$ -- домінантна вісь за якою відбуваються кроки, S -- інша вісь (X, Y = D, S або Y, X = D, S);
  \item $Error = floor(\Delta d / 2)$;
  \item Доки $d \neq d_1$:
  \item Записати (x, y) в p
  \item $Error = Error -  \Delta s$
  \item Якщо $Error < 0$, то: $s = s + ss$; $Error = Error + \Delta s$
  \item $d = d + sd$;
  \item Повернутись до "Доки";
  \item Записати $(x_1, y_1)$ в p;
  \item Повернути p.
\end{enumerate}

Для обрахунку кількості білих пікселів, алгоритм модифіковано наступним чином:
\begin{enumerate}
  \item p = 0;
  \item $\Delta x = |x_1 - x_0|$; $\Delta y = |y_1 - y_0|$;
  \item $sx = x_1 \geq x_0$; $sy = y_1 \geq y_0$;
  \item $x = x_0$; $y = y_0$;
  \item $D = argmax(\Delta x, \Delta y)$ -- домінантна вісь за якою відбуваються кроки, S -- інша вісь (X, Y = D, S, або Y, X = D, S);
  \item $Error = floor(\Delta d / 2)$;
  \item Доки $d \neq d_1$:
  \item $p = p + Image[x][y]$;
  \item $Error = Error -  \Delta s$
  \item Якщо $Error < 0$, то: $s = s + ss$; $Error = Error + \Delta s$
  \item $d = d + sd$;
  \item Повернутись до "Доки";
  \item $p = p + Image[x_1][y_1]$;
  \item Повернути p.
\end{enumerate}

Маючи алгоритм обрахунку кількості білих точок на відрізку, можна застосувати його для чотирьох сторін чотирикутника, сума результатів може бути функцією оцінки. 
Але, в такій реалізації оцінка штрафує за збільшення кількості білих точок. 
Нехай $B_4$ -- сума результатів роботи модифікованого алгоритму Брезенхейма, тоді:
\[
\theta = \frac{1}{B_4}
\]
оцінка яка винагороджує за кількість білих точок. Проте, така оцінка буде давати однакову винагороду за 1 білий піксель для чотирикутників з периметром 4 і з периметром 100.
Щоб цього уникнути, можна домножити на периметр:
\[
\theta_{B_4} = \frac{\sum\limits_{i=1}^{4}E_i}{B_4}
\]

\subsection{Функція оцінки внутрішніх границь}
Оскільки на зображенні цілком ймовірно може бути присутній інший паралелограм, то він може задовольнити попередні оцінки. 
Якщо цей паралелограм містить паралелограм столу, то навіть використання точок попереднього регіону столу може не допомогти. 
Якщо один паралелограм містить інший -- значить в ньому є білі пікселі границь внутрішнього паралелограму.

Можна побудувати оцінку, яка враховує кількість білих пікселів в чотирикутнику. Щоб побудувати таку оцінку необхідно побудувати алгоритм перевірки належності пікселя до чотирикутника.

Якщо точка знаходиться в чотирикутнику, промінь з цієї точки в будь-якому напрямку перетне чотирикутник. Якщо чотирикутник не опуклий і цей промінь перетне іншу сторону -- промінь має перетнути третю сторону щоб залишити чтоирикутник.
Таким чином, якщо промінь з точки в будь-якому напрямку перетинає сторони чотирикутника один чи три рази -- точка знаходиться в чотирикутнику.

Якщо хоча б один промінь з точки не перетинає жодну зі сторін чотирикутника -- точка лежить поза чотирикутником. Якщо ж перетинів парна ненульова кількість -- промінь спочатку заходив, а потім виходив з чотирикутника.

Таким чином: якщо для довільного променя кількість перетинів парна -- точка лежить поза чотирикутником, якщо непрна -- в середині. Для алгоритму використано промінь вздовж осі X:
\begin{enumerate}
  \item $inside = False$;
  \item Для кожної сторони:
  \item $x_i, y_i, x_j, y_j$ -- координати вершин сторони;
  \item Якщо промінь вздовж Х між $y_i$ та $y_j$ і якщо точка перетину з прямою сторони в середині сторони -- є перетин, $inside = not\ inside$;
  \item Після проходу по всім сторонам -- повернути $inside$.
\end{enumerate}

Маючи алгоритм належності пікселя до чотирикутника, можна побудувати алгоритм підрахунку білих точок в середині чотирикутника:
\begin{enumerate}
  \item $c = 0$;
  \item Для кожної білої точки на зображенні:
  \item Якщо точка в чотирикутнику -- $c = c+1$;
\end{enumerate}

Таким чином, оцінка внутрішніх границь має вигляд $\theta = c$. 
Але така оцінка не враховує розмір чотирикутника, для врахування розміру слід ділити на площу чотирикутника:
\[
\theta_c = \frac{c}{S}\text{, де $d_i$ -- довжина діагоналі, S -- площа чотирикутника}
\]

\subsection{Комбінація функцій оцінки у фінтес-функцію}
Одними з найбільш простих способів об'єднань оцінок є додавання і множення. 
Для того щоб уникнути балансування оцінок між собою, обрано множення:
\[
fitness = \theta_\text{пар.}\cdot (\theta_{B_4}+c_3)\cdot (\theta_c + c_4)\text{, де $c_i$ -- константи уникнення занулення, які треба визначити експериментально}
\]

\section{Створення первинного набору даних}
\subsection{Створення зображень}
Для набору даних на камеру телефона знято 50 фотографій принтера в однаковому довкіллі і при однаковому освітленні 
(різні умови довкілля не розглядаються для демонстрації роботи методів і зменшення часу на навчання моделей). 
Приклад однієї з таких фотографій на рисунку 2.2.

\subsection{Розстановка розмітки на зображеннях}
Розглянувши декілька програм для встановлення розмітки на зображеннях, обрано Label Studio \cite{labelstudio} як безкоштовний застосунок.
Для 50 зображень створено анотації з чотирикутниками.

\begin{figure}[H]
  \center
  \includegraphics[width=0.7\textwidth]{LabelDemo.png}
  \textbf{\caption{Приклад розміченого зображення}}
  \label{fig:LabelDemo}
\end{figure}

\subsection{Збільшення варіативності набору даних}
Для збільшення варіативності набору даних, для кожного зображення створено 5 його версій: оригінальну, і чотири з випадковими шумом, поворотом та зміною кольору

TO DO!!!!!!


\chapter{Розробка програми}
\section{Реалізація загальних класів та функцій}
\subsection{Робота з зображеннями}
Створено клас \code{ImageContainer}, який містить масив значень пікселів від 0 до 1 у RGB або HSV та має метод для показу зображення на екрані.
Для роботи з класом створені функції: перетворення з RGB в HSV, усереднення трьох каналів, застосування матричний фільтр, порогової бінаризації, зміни розміру та перетворення зображення на масив позицій білих пікселів.

Окрім порогової бінаризації, створено функцію яка використовує бінарний пошук для знаходження значення порогу таке, що частка білих пікселів на зображенні приблизно дорівнює вказаному аргументу.

\subsection{Реалізація оцінок і фітнес-функції}
Створено клас \code{Quad} який при ініціалізації приймає масив з 8 значень: x1, y1, x2, ... y4. 
З цих значень обраховуються: масиви координат вершин (вершини сортуються за порядком обходу, щоб уникнути чотирикутників які виглядають як мінімалістичний піщаний годинник), 
довжин і кутів нахилу сторін; площа і периметр чотирикутника.

Оголошуються функції оцінок і конструктор фітнес функції, який бере на вхід константи і повертає функцію яка на вхід приймає лише масив з восьми змінних значень.

\section{Алгоритми знаходження чотирикутника з найкращим значенням фітнес-функції}
\subsection{Повний перебір}
Алгоритм повного перебору дозволяє достовірно обчислити найкращий чотирикутник, але за рахунок використання великої кількості обчислювальнового часу. 
Щоб такий алгоритм міг закінчити роботу щонайменше в поточному сторіччі, нобхідно зменшувати розмір вхідного зображення і використовувати паралелизацію. 

Створено функцію, яка для віхдного масиву білих пікселів робить повний перебір всіх строго зростаючих за індексом комбінацій білих пікселів.

Для подальших експериментів $c_i = 1$.

Для оригінального зображення (4080х2296 пікселів) для перебору необхідно 3.8 мільярдів років.
Для зменшеного в 16 разів зображення -- 2312 років. Для зменшеного в 64 рази -- 62 дні. Для зменшеного в 256 разів -- 90 секунд. 
\begin{figure}[H]
  \center
  \includegraphics[width=0.5\textwidth]{FullCalcSmall.png}
  \textbf{\caption{FullCalcSmall роботи повного перебору білих пікселів для границь зменшеного в 256 разів зображення}}
  \label{fig:LabelDemo}
\end{figure}

\begin{figure}[H]
  \center
  \includegraphics[width=0.5\textwidth]{FullCalcBig.png}
  \textbf{\caption{Результат роботи повного перебору на оригінальному зображенні}}
  \label{fig:FullCalcBig}
\end{figure}

Цей алгоритм не здатний визначити положення столу за менш ніж декілька місяців, тож його використання недоцільне.

\subsection{Випадковий перебір}
Випадковий перебір простий в реалізації, легкий в паралелизації, не потребує великої кількості часу, але й не гарантує результат.

Створено функцію яка робить вказану кількість випадкових перевірок і повертає найкраще значення фітнес-функції, значення координат і графік зміни фітнес-функції впродовж перебору.

Обраховано випадковий перебір протягом $10^5$ для зменшеного в 32 рази зображення:

\begin{figure}[H]
  \center
  \includegraphics[width=\textwidth]{RandomResult.png}
  \textbf{\caption{Зліва графік збіжності фітнес-функції до 0, справа знайдений чотирикутник на фоні границь}}
  \label{fig:RandomResult}
\end{figure}

З графіку видно, що випадковий перебір не в змозі отримати задовільні значення фітнес-функції.

\subsection{PSO та покращення фітнес-функції}
Створено функцію яка застосовує ройовий алгоритм PSO для вхідного зображення з заданими набором гіпер параметрів і кількістю ітерацій.

\begin{table}[H]
  \begin{center}
    \begin{tabular}{ |c|c| }
      \hline
      Основні параметри & Значення \\
      \hline
      Прискорення до найкращого власного значення & 1 \\
      \hline
      Прискорення до найкращого значення популяції & 1.5 \\
      \hline
      Розмір популяції & 250 \\
      \hline
      Максимальна швидкість & 100 \\
      \hline
      Збереження швидкості (анти гальмування) & 90\%\\ 
      \hline  
    \end{tabular}
    \caption{Таблиця значень гіпер параметрів для перших тестових запусків PSO}
    \label{table:1}
  \end{center}
\end{table}

\begin{figure}[H]
  \center
  \includegraphics[width=\textwidth]{PSOResultSmall.png}
  \textbf{\caption{Результат роботи PSO для зменшеного в 32 рази зображення протягом 250 ітерацій: зліва графік збіжності, справа отриманий чотирикутник}}
  \label{fig:PSOResultSmall}
\end{figure}

\begin{figure}[H]
  \center
  \includegraphics[width=\textwidth]{PSOResultMedium.png}
  \textbf{\caption{Результат роботи PSO для зменшеного в 8 разів зображення протягом 100 ітерацій: зліва графік збіжності, справа отриманий чотирикутник}}
  \label{fig:PSOResultMedium}
\end{figure}

З форми чотирикутника видно, що фітнес функція не враховує те, що ромб з малим кутом непогано задовольняє оцінки паралелограма. 
Додано оцінку, яка штрафує за різницю розміру діагоналей:

\[
\theta_{2D} = \frac{\left(D_1 - \frac{D_1+D_2}{2}\right)^2}{D_1} + \frac{\left(D_2 - \frac{D_1+D_2}{2}\right)^2}{D_2}.
\]

Також, модифіковано фітнес-функцію:

\[
fitness = \theta_\text{пар.}^2\cdot (\theta_{B_4}+c_3)^2\cdot (\theta_c + c_4)^2\cdot (\theta_{2D} + c_5)^2
\]

Але подальші декілька десятків тестових запусків і незначних змін фітнес-функції не призвели до задовільних резульататів. 

\subsection{Використання генетичного контексту для покращення фітнес-функції}
Для покращення результатів роботи алгоритмів, використано раніше створені методи отримання контексту. 
Задля отримання границь використовується маска для правила кольору столу, у фітнес функцію додано індикатор наявності точки столу в чотирикутник.
\begin{figure}[H]
  \center
  \includegraphics[width=\textwidth]{PSOResult2.png}
  \textbf{\caption{Результат роботи PSO для зменшеного в 16 разів зображення з границями контексту кольору столу протягом 100 ітерацій: зліва графік збіжності, справа отриманий чотирикутник}}
  \label{fig:PSOResult2}
\end{figure}

Оскільки робота з границями не дала бажаних результатів, використано пікселі з контекстом кольору столу і модифіковано $\theta_c = \frac{1}{c}$ для винагородження за кількість пікселів в середині чотирикутника. Якщо $\theta_c$ майже 1 -- більше винагороджувати за площу. Ігнорувати кількість пікселів на границі.
\begin{figure}[H]
  \center
  \includegraphics[width=0.5\textwidth]{PSOResult3.png}
  \textbf{\caption{Результат роботи PSO з 1000 частинок для зменшеного в 32 рази зображення з контекстом кольору протягом 50 ітерацій}}
  \label{fig:PSOResult3}
\end{figure}

\subsection{Використання генетичного алгоритму}
\subsubsection{Реалізація генетичного алгоритму}
Генетичний алгоритм реалізовано наступним чином: масив з масивів 8 координат кожної ітерації проходить кросовер, мутацію і селекцію. Кросовер випадковим чином обирає двох батьків і для кожної координати створює випадкове значення в межах значень координат батьків. 
Мутація з заданою ймовірністю і силою може посунути і повернути весь чотирикутник та випадковим чином трохи порухати координати, $\frac{1}{3}$ розміру популяції не підлягає мутації. Селекція сортує популяцію за значенням фітнес-функції та залишає лише найкращі хромосоми. 
Задля пришвидшення роботи коду, обчислення фітнес-функції при селекції паралелізовано.

Також, існує опція збільшення початкового набору хромосом, щоб алгоритм починав роботу з більш кращими хромосомами

\subsubsection{Використання генетичного алгоритму}
Виконано декілька обчислень для фітнес-функції для маски контексту столу і контексту точки столу. Ціль обчислень -- встановити чи може фітнес-функція що базується виключно на оцінці $\theta_c$ і контексті точки столу дати задовільний результат.

Обчислення показали, що така фітнес-функція провокує дуже вузькі чотирикутники, які захоплють по 2 пікселі, маючи середню ширину ~1. Додавання оцінки рівності діагоналей прибрало цю проблему, але код генерував трикутники. Додавання оцінки рівності протилежних кутів дало наступний результат:
\begin{figure}[H]
  \center
  \includegraphics[width=0.5\textwidth]{Genetic1.png}
  \textbf{\caption{Результат роботи генетичного алгоритму для фітнес-функції без перевірки пікселів на сторонах}}
  \label{fig:Genetic1}
\end{figure}
\begin{figure}[H]
  \center
  \includegraphics[width=0.5\textwidth]{Genetic2.png}
  \textbf{\caption{Результат роботи генетичного алгоритму для фітнес-функції з перевіркою пікселів на сторонах}}
  \label{fig:Genetic2}
\end{figure}
Після ще декількох експериментів з фітнес функцією: з $\theta_c$ прибрано штраф за площу, з $\theta_{B_4}$ прибрано штраф за периметр, фітнес функця є сумою оцінок з коефіцієнтами.


\chapter{Висновки}

% Бібліографія
\begin{thebibliography}{9}
\bibitem{bresenham}
Bresenham's line algorithm [Електронний ресурс]. – Режим доступу: \url{https://www.cs.helsinki.fi/group/goa/mallinnus/lines/bresenh.html} (дата звернення: 13.06.2025).
\bibitem{labelstudio}
Label Studio. Documentation guide [Електронний ресурс]. – Режим доступу: \url{https://labelstud.io/guide} (дата звернення: 13.06.2025).
\bibitem{numpy_linalg}
NumPy: Linear algebra (numpy.linalg) [Електронний ресурс]. – Режим доступу: \url{https://numpy.org/doc/2.2/reference/routines.linalg.html} (дата звернення: 13.06.2025).
\end{thebibliography}

\end{document}